
# 항해99 주특기 PBL 2-3주차 과제

### 🏁 **Goal:  "프론트엔드와 함께 로그인 사용자용 매거진 사이트 만들기"**

- 학습 과제를 끝내고 나면 할 수 있어요!
    1. 프론트엔드와 함께 협업할 수 있어요.
    2. 레이지 로딩, 이거 로딩이 무엇인 지 알고, ORM을 사용할 수 있어요.
    3. MySQL을 이용한 프로젝트를 구현할 수 있어요.

### 🚩 **Requirement:  과제에 요구되는 사항이에요**

- `과제 요구 사항`을 모두 완수해야 합니다!
<br>
<br>
    ✅ 과제 요구 사항


1. API List 를 프론트엔드와 논의하여 정하고, 그에 맞춰 구현하기
2. 회원 가입 페이지
트  - [x] 회원 가입을 구현할 때 인증 인가 방식은 자유롭게 선택해주시면 됩니다.
  - [x] 닉네임은 `최소 3자 이상, 알파벳 대소문자(a~z, A~Z), 숫자(0~9)`로 구성하기
  - [x] 비밀번호는 `최소 4자 이상이며, 닉네임과 같은 값이 포함된 경우 회원가입에 실패`로 만들기
  - [x] 비밀번호 확인은 비밀번호와 정확하게 일치하기

3. 로그인 페이지
   - [x] 로그인 버튼을 누른 경우 닉네임과 비밀번호가 데이터베이스에 등록됐는지 확인한 뒤, 하나라도 맞지 않는 정보가 있다면 "닉네임 또는 패스워드를 확인해주세요"라는 메세지를 프론트엔드에서 띄워줄 수 있도록 예외처리 하기

4. 로그인 검사
   - [x] 로그인 하지 않은 사용자도, 게시글 목록 조회는 가능하도록 하기
   - [x] 로그인하지 않은 사용자가 좋아요 버튼을 눌렀을 경우, "로그인이 필요합니다." 라는 메세지를 프론트엔드에서 띄워줄 수 있도록 예외처리 하기
   - [x] 로그인 한 사용자가 로그인 페이지 또는 회원가입 페이지에 접속한 경우 "이미 로그인이 되어있습니다."라는 메세지로 예외처리하기
   - 인증 인가를 어떤 개념(Token/Session)을 채택 했는지, 그 이유에 대해서 설명하기
```
    - jwt 학습을 위해 Token을 채택하였다.
   
    - 세션방식은 1차적으로 무상태성이 아니므로, 다중 서버에서 세션을 공유해야하는 로직이 필요로하다.
    
      하지만, 세션은 서버에서 사용자 인증 프로토콜을 손쉽게 조정할 수 있는 장점이 있다.

    - Token 방식은 무상태를 지킬수 있으며, 토큰에 사용자 인증 정보를 보관하기 떄문에,

      다중 서버 환경에서도 토큰을 받는 서버는 인증절차를 할 수 있어 로직을 간소화할 수 있다.

      다만, 토큰의 탈취에 인증시스템이 무방비하다. 탈취에 대한 별도의 로직이 필요한 이유이다.

      또한, 인증에 대한 제어권을 클라이언트/서버 모두 가지고 있으므로, 관리상 복잡한 로직이 필요하다.
```

5. CORS 해결하기
   - CORS란 무엇이며, 어떤 상황에서 일어나는지 / 어떻게 해결하는지 알아보고, 프로젝트에 적용하기
```
    - CORS는 현재시스템이 다른 시스템의 자원을 이용하는 것이다. 자원이라 함은.. 그냥 타 시스템의 서비스라 생각하면됩니다.
    
    - Spring Security에서는 Cors에 대한 옵션을 조정할 수 있다. [참고](https://www.baeldung.com/spring-cors)
    
        - CorsConfiguration 객체를 생성하여, 아래와 같이 설정한 다음. Web Security Configurer Adapter에 붙여두면된다.
        
           - addAllowedOrigin() : 허용할 출처
           
           - addAllowedHeader() : 허용할 헤더
           
           - addAllowedMethod() : 허용할 메서드
           
```


6. 좋아요 순 정렬(정렬하기는 꼭 해봐야 하는 건데 과제에 없다)
   - 정렬 기준 중 하나를 선택해주세요!
       - [x] 생성일 순
       - [ ] 좋아요 순
       - [ ] view 순

## ERD

![img.png](image/erd.png)


## API 리스트

![img.png](image/API_list.png)


---
# Lv3. 테스트

- [테스트전략](https://www.popit.kr/spring-guide-%ED%85%8C%EC%8A%A4%ED%8C%85-%EC%A0%84%EB%9E%B5/)
- [유닛테스트](https://galid1.tistory.com/772)
- [통합테스트](https://galid1.tistory.com/735)


## - 과제 내용

- Unit test와 Integration test는 무엇이고, 어떻게 하는지 알아보기

```
Unit test : 모듈(기능) 하나하나 독립적인 실행에 있어서 기대하는 결과를 검증
Integration test : 연계된 모듈(기능) 환경을 구성하여 상호작용 및 기대 결과를 검증  
```

- Integration test 시나리오 작성하기
    - 개발자의 관점이 아닌 고객 관점에서 작성해보세요!
  
    ```
    (인증 전체 프로세스 확인)
    case1. 더미 글 쓰기x100 > 회원가입 > 로그인 > 글 조회 > 글 쓰기 > 글 조회(1~3페이지) >
    랜덤번호 추출 > 해당 번호 글 수정 > 해당 글 조회 > 해당 글 삭제 > 로그 아웃
  
    (미인증 전체 프로세스 확인)
    case2. 더미 글 쓰기x100 > 글 조회 > 글 쓰기(or 수정, or 삭제) > 로그 아웃
  
    (인증 후 인증검증 확인)
    case3. 로그인 > 토큰변형(타임오버 등 간주) > #case1
    case4. 로그인 > 로그아웃 > 글 조회 > 글 쓰기
    case5. 로그인 > 로그아웃 > 로그인 > 글 조회 > 글 쓰기
    case6. id 1 로그인 > 로그 아웃 > id 2 로그인 > 로그 아웃 > id 3 로그인 > 로그 아웃 ...
    case7. 로그인 > 브라우저 종료 > 글 조회 > 글 쓰기
    case8. 로그인 > 다른페이지 이동 > 글 조회 > 글 쓰기
    
    (회원가입 검증 확인)
    case9. id, nickname 등 중복 회원가입
    case10. 로그인 > 회원가입
  
    (로그인 검증 확인)
    case11. id, password 등 임의 생성하여 로그인
    case12. 로그인 > 로그인
  
    (다중 로그인 확인)
    case13. 동일 id로 멀티 디바이스 로그인 > #case1
    
    ```
  
- 서비스 레이어 테스트 코드 커버율 70% 이상 만들어오기

### - [4월23일 작업](개발일기/8일차.md)

---

# Lv4. 리펙토링

## - 과제 내용

- Builder 패턴이란 무엇이며, 왜 써야하는지 알아보기

```
1. 객체 생성(new)시 직관적인 생성설정을 넘겨줌으로써 휴먼에러 발생을 낮춘다.
2. 생성인자를 순서(?,?,?)가 아닌 메소드 호출을 통해 이루어 짐으로써, 객체 클래스 변경에 자유롭다. (독이 될지도?)
   * 순서정함이 없이 이루어 진다면, 위 장점뿐만 아니라, 필수인자 추가가 발생할 경우 추가요소 추적이 어려워 보인다.
   * 빌더를 적용하더라도, 필수인자는 빌더내부에서도 생성자를 통해 받아줘야할것으로 보인다.
3. 2번의 단점을 극복하기 위한 방식으로 생성인자에 대한 전처리를 독립적으로 할 수 있다.
   * 단, 전처리시 다른 생성인자가 필요한 경우를 고려해야할 것 같다. (b를 처리하기위해 a가 필요한데 a가 아직 안받아졌다면??)
   * 위 단점을 위해.. 역시 2번의 해법처럼 전처리시 필요한 필드는 필수인자로 받아야할 듯 하다.
4. 객체 생성에 따른 유효성 검사를 동적으로 할 수 있다.
5. setter의 미사용으로 객체의 최소한의 불변성을 유지할 수 있다. (바뀔 부분은 바껴야한다. 그러므로 최소한 불변한것은 지킬 수 있다.)
```

- 프로젝트에 Builder 패턴 적용해보기 (인자가 많은 클래스에 한해서)
- 게시물 수정 기능을 어떻게 Builder 디자인 패턴을 위배하지 않고, 생성한 객체를 수정할 때 어떤 문제점이 있는지 파악하고, 이를 해결하기 위해 어떻게 하면 좋을지 생각해오기

```
필드 수정을 위해 단순하게 setter를 보통 사용한다. 다만, setter의 의미는 매우 범용적이므로 의도하지 않은 상황에서 호출이 될 여지가 있다.
그러므로 setXXX 보다는 initXXX, updateXXX, deleteXXX 등 필드 변경 목적에 맞는 메소드 명을 부여하고,
변경 목적에 맞게끔 검증 후 필드를 변경하는 것이 좋아 보인다. (검증 예, deleteXXX 호출 후 값을 주거나, updateXXX 호출 후 null을 준다거나?)
```

- Builder 패턴에 대한 본인의 생각 정리해오기

```
빌더를 채택하는 것은 매우 주관적인 요소라고 판단 된다. 단순히 getter, setter, 불변, 생성의 객관성 ... 등의 사유로 빌더를 채택한다? 어불성설로 느껴진다.
패턴은 다양한 모양이 있고, 제각각 상황에 따른 용법이 정해져있다.
빌더 패턴 또한 특정 '상황'에 따른 용법이다. 단지, 모든 패턴이 그것을 효율,효과적으로 쓰이느냐? 의 차이로 쓸지말지 정해진다고 본다.
이번 리펙토링?을 해보면서 느낀점은 JAP Entity 클래스에 빌더가 필요할까? 의문이였고, DTO 클래스들은 나름 필요해보이네? 라고 생각이 든다.
Entity 객체의 생성은 상황에 맞는 DTO객체를 통해 생성하면된다. 그것이 오히려 깔끔해 보인다.
다만 DTO 객체는 동적으로 생성해야할 필요가 느껴진다. (감만 있지,, 프로젝트 규모상 쓰임세는 크게 느끼지 못하였다)

아무튼.. 빌더를 채택할 이유에 대한 내 생각은..
1. 종속되지않은 클래스이면서,   (쓰이는곳이 다양하게 있다)
2. 다양한 상태의 객체가 될 수 있고,  (객체들의 필드값이 다양하게 들어간다)
3. 객체 생성에 따른 전처리가 있고,   (빌더패턴은 전처리를 독립적으로 할 수 있다.)
4. 클래스의 변화여지가 있고,   (없던 필드가 추가된다.)
*. 생성자가 나름 많다면? (현재의 내 기준 3개 이상이면?)

빌더패턴을 적용하기 아주 적합해 보인다고 생각이 든다. (이유를 쓰면서 DTO 클래스를 많이 모방했다)
-현재의 고정관념으로는 딱, Entity클래스는 일단 생성자. DTO는 빌더라고 느껴진다.
 단, Entity클래스의 생성자는 JPA와 DTO만을 위한 생성자만 있으면된다.
```

- N+1 문제 해결하기
    - N+1 문제란 무엇이고, 우리 프로젝트에서 N+1 문제에 해당하는 내용 있는지 알아보고 있다면 해결하기

```
'사설' = 위 문제를 어느정도 이해하고나서, 왜 N+1일까? 1+N 아닌가? 라고 의문이 들었다.
나름.. 정립한 이유는 N개의 문제를 해결하여 드디어 1개의 목표를 이루었다? 였다.
저걸 반대로 생각하면, 내가 생각한 1+N이 된다. 1개의 목표를 위해 N개의 문제를 해결한다. 이다.
아무튼.. 이걸 해결하는 방법? 그냥 목표로 하는걸 한방에 가져오면 되지않나?? (라는 단순한 생각이 먼저 들었다)
----------
(밑 부분부터는 학교와 학생을 예로 듭니다~)
JPA를 공부하면서 참 다양한 문제가 있었다. N+1도 그 중 하나이고 간결함의 배신이라 느껴진다. 간결하다보니 복잡하게 짜야하는 현실?
아무튼.. 위 문제는 사설에 있듯이 목표로 한건 1개의 행위였지만, 의도치 않게 연관된 N개의 행위가 부수적으로 발생하는 것이다.
JPA에서는 연관관계 매핑 필드(Join)에서 일어난다.
뭐 사설에 있듯이 한방에 가져오면? 되긴 된다. 다만 또다른 의도로 N+1 문제가 발생하겠지만..
 *A학교를 조회 했더니 A학교의 학생들이 한방에 가져와 지는건 좋다.   (... where 학교명 like 'A'; )
 *그렇다면, 전국의 모든 학교를 조회하면? 결과가 어찌될지는 고민해자. (select * from 학교테이블;)

아무튼.. 한방에 조회해도 문제는 터진다. 그럼 LAZY에서도 터지고, EAGER에서도 터지면 어떻게 해야할까?
가장 먼저 든 생각은...(역시 단순하게도) N개를 N/2 , N/3, N/50... 으로 줄이면 되지않나? 였다.
하지만 빅오를 보았다면 알듯 N/N 이 아닌이상 결국 N이라고 볼 수 있다.

글을 쓰면서 생각치도 못한 답이 나왔다. 내 나름의 답은 N/N이 결국 답이다.

결국 JPQL이라는 수동 쿼리?를 짜면된다. JPA가 해석하는데 약간?의 힌트를 부여하는 것이라 생각한다.
 *방법은 너무나 다양해서 상황에 맞는 방법을 검색하자..
```
